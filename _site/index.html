<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Welcome to ArcadeVS Documentation | [&#8221; &#8220;]</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Welcome to ArcadeVS Documentation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="[&#8221; &#8220;]" />
<meta property="og:description" content="[&#8221; &#8220;]" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="[&#8221; &#8220;]" />
<script type="application/ld+json">
{"url":"http://localhost:4000/","name":"[&#8221; &#8220;]","headline":"Welcome to ArcadeVS Documentation","description":"[&#8221; &#8220;]","@type":"WebSite","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="/assets/css/style.css?v=2c68e1f5ab97241367f846adaa01c5ebc93021c3">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name"> </h1>
      <h2 class="project-tagline"> </h2>
      
        <a href="https://github.com/PoyoWorks/ArcadeVS_DemoProject" class="btn">View on GitHub</a>
      
      
    </section>

    <section class="main-content">
      <h2 id="welcome-to-arcadevs-documentation">Welcome to ArcadeVS Documentation</h2>

<p>Here you will find the documentation for UE4 Marketplace <strong>Arcade Vehicle System</strong> plugin.
If you’re looking for the documentation for the Demo Project that comes with the plugin, it’s <a href="Documentation/doc_demo_project.md">here</a></p>

<h3 id="introduction--goal">Introduction / Goal</h3>

<h3 id="some-notes-on-vehicle-systems-in-general">Some notes on Vehicle Systems in general</h3>

<h2 id="plugin-architecture">Plugin architecture</h2>
<p>ArcadeVS is a <strong>code plugin with content</strong>. The main Vehicle System is just one C++ class that inherits UE <strong>Pawn</strong>’s class, it’s self contained. 
<em>The idea was to have all the logic at the same place, easily understandable and to have all the system’s parameters properly exposed on the root object.</em></p>

<p>This means that you won’t have to dig into your components to find a specific settings or won’t have to create complex stuff like Tire Materials to get your vehicle up and running.</p>

<p>The plugin also contains some example blueprint vehicles classes and animation blueprints. Those vehicles inherits the main Vehicle System class and serves as examples on how to properly setup a vehicle. They have a skeletal mesh, some suspension points registered and their parameters have been fine tuned to make sure that they behave properly.</p>

<h3 id="c-vehicle-system">C++ Vehicle System</h3>
<p>The Vehicle System is physics based. This means that all movement is due to physic forces being applied to the root component of the Vehicle Actor, which is the Skeletal Mesh component.</p>
<h4 id="features">Features</h4>
<p>Here is a list of the main features of the Vehicle System. For a complete list of all the settings available, please check the [Vehicle System Settings page].</p>
<ul>
  <li><strong>Suspension system</strong>: the suspensions are implemented using raycasts. This means that your wheels will not have any collision at all. Only the body of the car will have an actual collision geometry. This works very weel in practice and simplifies the setup of a Vehicle a lot. The suspensions have settings for height and damping. For all details please check here [Setting Up a Vehicle]</li>
  <li><strong>Acceleration</strong>: can be controlled either by an InputAction (when using a simple button) or an InputAxis (when using a Trigger for example)</li>
  <li><strong>Braking</strong>: can also be controller by an InputAction or InputAxis. Supports going in Reverse when braking and speed is &lt; 0.</li>
  <li><strong>Turning</strong>: works by adding torque to the Vehicle. Turning works in conjuction with adherence, if you were to set the Adherence force to 0 the car would simply rotate around it’s Z-axis while keeping the same direction. Supports setting min and max turning speed based on your current speed to give the feeling of a power steering system (see Settings). Support wheels direction smoothing and animation back to rest position.</li>
  <li><strong>Adherence</strong>: works by adding a lateral force proportional to the slide angle of the vehicle. This is what gives the feeling of sticking to the road or sliding/drifting.</li>
  <li><strong>Jumping</strong>: works by deactivating suspension forces for a short amount of time and applying and upward force.</li>
  <li><strong>In Air Stabilization</strong>: if enabled, this will try to align the vehicle up vector with the Z-vector when the vehicle is considered airborne. This can also be used if the car is stuck flipped to make it go back on its wheels.</li>
  <li><strong>Drifting</strong>: with the simplest settings, drifting simply applies a nerf to the adherence force and an offset to the turning scale registered from the controller. But I wanted to get as close as I could to the Mario Kart system so I’ve added many settings to allow for keeping your speed while drifting, increasing your rotation angle and other cool stuff. You can check all the drift mechanic settings [here]</li>
</ul>

<h3 id="c-visualizer">C++ Visualizer</h3>
<p>The C++ Visualizer is an Actor Component that can be added to any ArcadeVSVehicle class. It will help you debug and fine tune the setup of your vehicle by drawing on the screen the main forces applied to your vehicle at runtime.</p>

<p><img src="/assets/images/visualizer_3.png" alt="" />
<em>On this screenshot, the yellow arrow represents the velocity of the vehicle, the green arrow its acceleration and the purple one its adherence. You can also see the suspension raycasts. The vectors are drawn each frame and the time that they stay displayed can be configured. Here the time was set to .1 to see around 6f assuming we’re running @60fps (~0.016</em>6)</p>

<h4 id="settings">Settings</h4>
<p>Here are some details about some parameters</p>
<ul>
  <li><strong>Debug Material</strong>: a custom material that will override the vehicle mesh material. This is quite handy for debugging the suspension system buy using a transparent material. This will allow you to exactly see the start and end point of the suspension raycasts as well as the center of gravity of the vehicle.</li>
  <li><strong>Life Time</strong>: the time that each force / raycast drawn will stay displayed. The setting that I find the most usefull is to set it to 0.016 while locking your framerate at 60fps in the Editor by using the Console command t.MaxFPS 60. This will ensure that you only see all the forces for the current frame.</li>
  <li><strong>Force scaling</strong>: To make the drawing of the forces relevant, they must have the same scale so that seeing a vector twice as big as another actually means that the force is twice as big. To do this, all forces are taken as is but are multiplied by a scale factor so that they don’t look completely oversized on screen. The default value should work in most cases but if you’re working on a huge or very small vehicle you may want to slightly adjust it.</li>
</ul>

<p><img src="/assets/images/visualizer_1.png" alt="" />
<img src="/assets/images/visualizer_2.png" alt="" /></p>

<p>By  creating either a C++ or Blueprint class inheriting the Visualizer, you could add your own routines to draw any new or existing properties of your Vehicle that you would like to monitor/debug.</p>

<h3 id="c--blueprint-api">C++ / Blueprint API</h3>
<h4 id="c">C++</h4>
<p>The Vehicle System Logic is done in C++, but almost all functions are marked virtual and can be overriden by extending the class in C++. <em>The goal is that anyone can customize the system like he wants</em>. For example, if you don’t like how the vehicles accelerate or jump, simply create a new C++ vehicle class and rewrite the <strong>Accelerate()</strong> or <strong>Jump()</strong> functions.</p>

<h4 id="blueprints-events">Blueprints Events</h4>
<p>For Blueprints, most of the parameters concerning the current state of the Vehicle are exposed to blueprints to make adding Blueprint gameplay logic easier and keep your classes cleaner. Do you want to add a Particle VFX where the wheels contact with the ground? Simply check the <strong>Suspension Hit Results</strong> array and look for the <strong>ImpactPoint</strong> values.</p>

<p><img src="/assets/images/api_state.png" alt="" /><br />
<em>The data will also be visible when debugging at runtime</em></p>

<p>There’s also specific Blueprint implementable events broadcasted for every major state change in the system that you can easily implement to trigger VFX, SFXs or whatever logic you want.</p>

<p><img src="/assets/images/api_events.png" alt="" />
<em>This is a screenshot from the Kart Vehicle Blueprint that shows how you can simply add gameplay and visual details on a Vehicle by using the provided Blueprint events API</em></p>

<h3 id="c-playercontroller-and-simple-animationinstance">C++ PlayerController and simple AnimationInstance</h3>

<p>The two additional C++ classes that come with the project are very simple. 
The PlayerController class is here to give a simple example on how to setup a PlayerController for a Vehicle. This class does not setup any bindings, it just acts as a base class for a Blueprint PlayerController class. The idea is to have the logic in C++ and the actual Action/Axis bindings in the Blueprint.</p>

<p>The AnimationInstance acts just an interface. Right now, the SkeletalMesh Animation Instance is driven by the ArcadeVS C++ vehicle class. The vehicle class is responsible to update the animation instance wheels rotation, wheels direction and drift direction variables so that the animation can react properly.</p>

<h2 id="blueprints">Blueprints</h2>
<p>The plugin comes with some Blueprint classes to demonstrate its features.</p>

<p><img src="/assets/images/blueprint_content.png" alt="" /></p>

<h3 id="test-vehicle">Test Vehicle</h3>
<p>The Test Vehicle is simple ArcadeVS Vehicle with almost no Blueprint Logic added. It has a dummy Skeletal Mesh that has been rigged to have 4 wheels bones when the center of the wheels would be. Those bones are used as the location points for the Suspension System.</p>

<p>Its settings are very close to the default settings of the system.
It has the following behavior:</p>
<ul>
  <li>Offset center of mass to the front (where the engine would be)</li>
  <li>Suspensions are a little loose</li>
  <li>Good adherence, the vehicle will never drift without user action</li>
  <li>Little adherence force vertical offset to give the feeling that the car is rolling when turning at high speed</li>
  <li>Drift settings where it will not loose too much speed while loosing a little adherence and getting a nice turn angle boost</li>
</ul>

<p><img src="/assets/images/test_vehicle.png" alt="" /></p>

<h3 id="kart-vehicle">Kart Vehicle</h3>
<p>The Kart Vehicle is more advanced than the Test Vehicle and is a demo on what a more advanced / real game vehicle could look like. It has a textured and animated Skeletal Mesh as well as some Blueprint logic hooked to the Blueprint Events API to trigger Material and Particles Effects.</p>

<p>Its behavior is different from the Test Vehicle:</p>
<ul>
  <li>Very stable, it’s center of mass if adjusted to the center of its physics collision geometry and lowered</li>
  <li>Airborne stabilization, will never rollover</li>
  <li>Lot of suspensions damping</li>
  <li>Full adherence</li>
  <li>Drift settings will make it almost gain speed while drifting and it will have a big turn angle boost</li>
</ul>

<p><img src="/assets/images/kart_vehicle.png" alt="" /></p>

<h3 id="animation-system">Animation System</h3>
<p>The Animation Instance Blueprints supports wheels rotation, front wheels direction and drift direction. All those values comes from the C++ interface and are updated each frame by the Vehicle System. The blueprint updates the position and rotation of each wheel bones to reflect the changes.</p>

<p>To use this blueprint, simply assign it to your skeletal mesh and update the names of the wheel bones in each Transform/Modify bone node.</p>

<p><img src="/assets/images/animation_system.png" alt="" /></p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/PoyoWorks/ArcadeVS_DemoProject">ArcadeVS_DemoProject</a> is maintained by <a href="https://github.com/PoyoWorks">PoyoWorks</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
